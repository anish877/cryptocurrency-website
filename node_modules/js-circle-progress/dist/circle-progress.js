/*!
 * Circle Progress - v1.0.0-beta.0 - 2023-07-17
 * https://tigrr.github.io/circle-progress/
 * Copyright (c) Tigran Sargsyan
 * Licensed MIT
 */
class CustomElement extends HTMLElement {
	static styles = ''
	static props = {}

	// A map of property names to attribute names
	#propToAttrDict = {}
	// A map of attribute names to property names
	#attrToPropDict = {}

	#boolProps = new Set()

	constructor() {
		super();
		const shadowRoot = this.attachShadow({ mode: 'open' });

		// @ts-ignore
		const {styles} = this.constructor;
		if (styles) {
			const style = document.createElement('style');
			style.textContent = styles;
			shadowRoot.append(style);
		}

		// @ts-ignore
		const {props} = this.constructor;
		if (props) {
			for (const [prop, config] of Object.entries(props)) {
				if (config.attribute) {
					this.#propToAttrDict[prop] = config.attribute;
					this.#attrToPropDict[config.attribute] = prop;
				}
				if (config.type === Boolean) {
					this.#boolProps.add(prop);
				}
			}
		}
	}

	/**
	 * Update the element with a new property and value.
	 * @param {string} prop - The name of the property to update.
	 * @param {*} value - The new value for the property.
	 * @return {void}
	 */
	// @ts-ignore
	attributeUpdated(prop, value) {}

	/**
	 * Convert attribute name to property name
	 * @param {string} name Attribute name
	 * @return {string} Property name
	 */
	_attrNameToProp(name) {
		return this.#attrToPropDict[name] ?? name
	}

	/**
	 * Convert property name to attribute name
	 * @param {string} name Property name
	 * @return {string} Attribute name
	 */
	_propToAttrName(name) {
		return this.#propToAttrDict[name] ?? name
	}

	/**
	 * Convert attribute value to property value
	 * @param {string} name Attribute name
	 * @param {(string|null)} value Attribute value
	 * @return Property value
	 */
	_attrValToProp(name, value) {
		if (this.#boolProps.has(name)) {
			return value !== null
		}
		return value
	}

	#bailOutAttrUpdate = false

	attributeChangedCallback(name, _, newValue) {
		if (this.#bailOutAttrUpdate) {
			this.#bailOutAttrUpdate = false;
			return
		}
		this.attributeUpdated?.(this._attrNameToProp(name), this._attrValToProp(name, newValue));
	}

	reflectPropToAttribute(prop) {
		const value = this[prop];
		this.#bailOutAttrUpdate = true;
		const attr = this._propToAttrName(prop);
		if (this.#boolProps.has(prop)) {
			if (value) {
				this.setAttribute(attr, '');
			} else {
				this.removeAttribute(attr);
			}
		} else if (typeof value === 'function') {
			this.removeAttribute(attr);
		} else {
			this.setAttribute(attr, String(value));
		}
	}
}

/**
 * Create new paper holding a new SVG element
 * @param  {(HTMLElement|ShadowRoot|string)} container      Container element or selector string
 * @param  {(number|string)}      width          SVG width
 * @param  {(number|string)}      height         SVG height
 * @param  {Document}             [doc=document] HTML document. Defaults to current document
 * @return {Object}                              The paper
 */
const paper = function(container, width, height, doc) {
	doc = doc || document;

	const me = Object.create(paperProto);

	if(typeof container === 'string') {
		container = /** @type {HTMLElement} */ (doc.querySelector(container));
	}

	if(!container) {
		return;
	}

	const svg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');
	svg.setAttribute('version', '1.1');
	if(width) svg.setAttribute('width', String(width));
	if(height) svg.setAttribute('height', String(height));
	if(width && height) svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
	container.appendChild(svg);

	me.svg = svg;
	return me;
};

const paperProto = {
	/**
	 * Create a new SVG element
	 * @param  {string}     name      Element name
	 * @param  {Object}     attrs     Map of attributes
	 * @param  {string}     content   Element content
	 * @param  {SVGElement} [parent]  An element to append to. Defaults to the root SVG element
	 * @return {object}               Element
	 */
	element: function(name, attrs, content, parent) {
		const el = element(this, name, attrs, parent);
		if(content) el.el.innerHTML = content;

		return el;
	},
};

/**
 * General purpose element maker
 * @param  {Object}     paper    SVG Paper
 * @param  {string}     name     Element tag name
 * @param  {Object}     attrs    Attributes for the element
 * @param  {SVGElement|{el:SVGAElement}} [parent] Another SVG Element to append to
 * @param  {Document}   [doc]    Document
 * @return {Object}              Element
 */
const element = function(paper, name, attrs, parent, doc) {
	doc = doc || document;

	const me = Object.create(elementProto);

	me.el = doc.createElementNS('http://www.w3.org/2000/svg', name);
	me.attr(attrs);

	(parent ? ('el' in parent ? parent.el : parent) : paper.svg).appendChild(me.el);

	return me;
};

const elementProto = {
	/**
	 * Set an attribute to a value
	 * @param  {string} name  Attribute name
	 * @param  {*}      value Attribute value
	 * @return {object}       The element
	 *//**
	 * Set attributes
	 * @param {object} name  Map of name - values
	 * @return {object}       The element
	 */
	attr: function(name, value) {
		if(name === undefined) return this;
		if(typeof name === 'object') {
			for(let key in name) {
				this.attr(key, name[key]);
			}
			return this;
		}
		if(value === undefined)
			return this.el.getAttributeNS(null, name);
		this.el.setAttribute(name, value);
		return this;
	},
	/**
	 * Set content (innerHTML) for the element
	 * @param  {string} content String of SVG
	 * @return {object}         The element
	 */
	content: function(content) {
		this.el.innerHTML = content;
		return this;
	}
};

/**
 * Change any value using an animation easing function.
 * @param  {string}   easing Easing function.
 * @param  {number}   startValue The initial value
 * @param  {number}   valueChange Change in value
 * @param  {number}   dur Animation duration
 * @param  {Function} cb Callback to be called on each iteration. The callback is passed one argument: current value.
 * @return {Object}   Object with cancel method to stop the animation.
 */
const animator = function(easing, startValue, valueChange, dur, cb) {
	const easeFunc = typeof easing === 'string' ? easings[easing] : easing;
	let tStart;
	let animHandle;

	const frame = function(t) {
		if(!tStart) tStart = t;
		t -= tStart;
		t = Math.min(t, dur);
		const curVal = easeFunc(t, startValue, valueChange, dur);
		cb(curVal);
		if(t < dur) animHandle = requestAnimationFrame(frame);
		else cb(startValue + valueChange);
	};

	animHandle = requestAnimationFrame(frame);

	return {
		cancel: () => {
			cancelAnimationFrame(animHandle);
		}
	}
};


/**
 * Map of easings' strings to functions
 * Easing functions from http://gizma.com/easing/
 * @type {Object}
 */
const easings = {
	linear:  function (t, b, c, d) {
		return c*t/d + b;
	},

	easeInQuad: function (t, b, c, d) {
		t /= d;
		return c*t*t + b;
	},
	easeOutQuad: function (t, b, c, d) {
		t /= d;
		return -c * t*(t-2) + b;
	},
	easeInOutQuad: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return c/2*t*t + b;
		t--;
		return -c/2 * (t*(t-2) - 1) + b;
	},

	easeInCubic: function (t, b, c, d) {
		t /= d;
		return c*t*t*t + b;
	},
	easeOutCubic: function (t, b, c, d) {
		t /= d;
		t--;
		return c*(t*t*t + 1) + b;
	},
	easeInOutCubic: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return c/2*t*t*t + b;
		t -= 2;
		return c/2*(t*t*t + 2) + b;
	},

	easeInQuart: function (t, b, c, d) {
		t /= d;
		return c*t*t*t*t + b;
	},
	easeOutQuart: function (t, b, c, d) {
		t /= d;
		t--;
		return -c * (t*t*t*t - 1) + b;
	},
	easeInOutQuart: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return c/2*t*t*t*t + b;
		t -= 2;
		return -c/2 * (t*t*t*t - 2) + b;
	},

	easeInQuint: function (t, b, c, d) {
		t /= d;
		return c*t*t*t*t*t + b;
	},
	easeOutQuint: function (t, b, c, d) {
		t /= d;
		t--;
		return c*(t*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return c/2*t*t*t*t*t + b;
		t -= 2;
		return c/2*(t*t*t*t*t + 2) + b;
	},

	easeInSine: function (t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},

	easeInExpo: function (t, b, c, d) {
		return c * Math.pow( 2, 10 * (t/d - 1) ) + b;
	},
	easeOutExpo: function (t, b, c, d) {
		return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
	},
	easeInOutExpo: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
		t--;
		return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
	},

	easeInCirc: function (t, b, c, d) {
		t /= d;
		return -c * (Math.sqrt(1 - t*t) - 1) + b;
	},
	easeOutCirc: function (t, b, c, d) {
		t /= d;
		t--;
		return c * Math.sqrt(1 - t*t) + b;
	},
	easeInOutCirc: function (t, b, c, d) {
		t /= d/2;
		if (t < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		t -= 2;
		return c/2 * (Math.sqrt(1 - t*t) + 1) + b;
	},
};

// Utility functions
// Mathematical functions

/**
 * Convert polar coordinates (radius, angle) to cartesian ones (x, y)
 * @param  {number} r      Radius
 * @param  {number} angle  Angle
 * @return {object}       Cartesian coordinates as object: {x, y}
 */
const polarToCartesian = (r, angle) => ({
	x: r * Math.cos(angle * Math.PI / 180),
	y: r * Math.sin(angle * Math.PI / 180),
});

/**
 * Make sector path for use in the "d" path attribute
 * @private
 * @param  {number} cx         Center x
 * @param  {number} cy         Center y
 * @param  {number} r          Radius
 * @param  {number} startAngle Start angle relative to straight upright axis
 * @param  {number} angle      Angle to rotate relative to straight upright axis
 * @param  {boolean}  clockwise  Direction of rotation. Clockwise if truethy, anticlockwise if falsy
 * @return {string}           Path string
 */
const makeSectorPath = (cx, cy, r, startAngle, angle, clockwise = false) => {
	if(angle > 0 && angle < 0.3) {
		// Tiny angles smaller than ~0.3° can produce weird-looking paths
		angle = 0;
	} else if(angle > 359.999) {
		// If progress is full, notch it back a little, so the path doesn't become 0-length
		angle = 359.999;
	}
	const endAngle = startAngle + angle * (+clockwise * 2 - 1);
	const startCoords = polarToCartesian(r, startAngle);
	const endCoords = polarToCartesian(r, endAngle);
	const x1 = cx + startCoords.x;
	const x2 = cx + endCoords.x;
	const y1 = cy + startCoords.y;
	const y2 = cy + endCoords.y;

	return ["M", x1, y1, "A", r, r, 0, +(angle > 180), +clockwise, x2, y2].join(' ')
};

var styles = /* css */`
	:host(:not([hidden])) {
		display: inline-block;
	}

	.circle {
		fill: none;
		stroke: #ddd;
	}

	.value {
		fill: none;
		stroke: #00E699;
	}

	.text {
		font: 16px Arial, sans-serif;
		text-anchor: middle;
		fill: #999;
	}

	:host([text-format="valueOnCircle"]) .text-value {
		font-size: 12px;
		fill: #fff;
	}

	:host([text-format="valueOnCircle"]) .text-max {
		font-size: 22px;
		font-weight: bold;
		fill: #ddd;
	}

	:host([text-format="vertical"]) .text-separator {
		font-family: Arial, sans-serif !important;
	}
`;

/**
 * @author Tigran Sargsyan <tigran.sn@gmail.com>
 */


const ariaAttrs = {value: 'aria-valuenow', min: 'aria-valuemin', max: 'aria-valuemax'};


/**
 * Create a new Circle Progress bar
 * @class Circle Progress class
 */
class CircleProgress extends CustomElement {
	static styles = styles

	/**
	 * @type {number} Current value
	 */
	value

	/**
	 * @type {number} Minimum value
	 * @default 0
	 */
	min

	/**
	 * @type {number} Maximum value
	 * @default 1
	 */
	max

	/**
	 * @type {number} Start angle
	 * @default 0
	 */
	startAngle

	/**
	 * @type {boolean} Whether to draw the circle anticlockwise
	 * @default false
	 */
	anticlockwise

	/**
	 * @type {boolean} Whether to allow values outside of the min-max range
	 * @default false
	 */
	unconstrained

	/**
	 * @type {string} Text to display when the value is indeterminate
	 * @default '?'
	 */
	indeterminateText

	/**
	 * @type {string|Function} Text format
	 * @default 'horizontal'
	 */
	textFormat

	/**
	 * @type {string} Animation easing function
	 * @default 'easeInOutCubic'
	 */
	animation

	/**
	 * @type {number} Animation duration in milliseconds
	 * @default 600
	 */
	animationDuration

	static props = {
		value: true,
		min: true,
		max: true,
		startAngle: {attribute: 'start-angle'},
		anticlockwise: {type: Boolean},
		unconstrained: {type: Boolean},
		indeterminateText: {attribute: 'indeterminate-text'},
		textFormat: {attribute: 'text-format'},
		animation: true,
		animationDuration: {attribute: 'animation-duration'},
	}

	static get observedAttributes() {
		return Object.entries(this.props).map(
			([name, config]) => (config && typeof config === 'object' && config.attribute) || name
		)
	}

	static defaults = {
		startAngle: 0,
		min: 0,
		max: 1,
		unconstrained: false,
		indeterminateText: '?',
		anticlockwise: false,
		textFormat: 'horizontal',
		animation: 'easeInOutCubic',
		animationDuration: 600
	}

	/**
	 * Construct the new CircleProgress instance
	 * @constructs
	 * @param {Object}                opts  Options
	 */
	constructor(opts = {}) {
		super();

		Object.defineProperties(
			this,
			Object.keys(CircleProgress.props).reduce(
				(descriptors, prop) => {
					descriptors[prop] = {
						get() {
							return this._get(prop);
						},
						set(val) {
							this.attr(prop, val);
						},
					};
					return descriptors;
				},
				{}
			)
		);

		let circleThickness;

		opts = {...CircleProgress.defaults, ...opts};

		circleThickness = opts.textFormat === 'valueOnCircle' ? 16 : 8;

		this.graph = {
			paper: paper(this.shadowRoot, 100, 100),
			value: 0,
		};
		this.graph.paper.svg.setAttribute('class', 'base');
		this.graph.paper.svg.setAttribute('part', 'base');
		this.graph.paper.svg.setAttribute('role', 'progressbar');
		this.graph.circle = this.graph.paper.element('circle').attr({
			class: 'circle',
			part: 'circle',
			cx: 50,
			cy: 50,
			r: 50 - circleThickness / 2,
			'stroke-width': circleThickness,
		});
		this.graph.sector = this.graph.paper.element('path').attr({
			d: makeSectorPath(50, 50, 50 - circleThickness / 2, 0, 0),
			class: 'value',
			part: 'value',
			'stroke-width': circleThickness,
		});
		this.graph.text = this.graph.paper.element('text', {
			class: 'text',
			part: 'text',
			x: 50,
			y: 50,
		});
		this._initText();
		Object.keys(CircleProgress.props)
			.forEach(key => key in opts && this._set(key, opts[key]));
	}

	// Called from CustomElement whenever attribute is changed
	attributeUpdated(name, newValue) {
		this._set(name, newValue);
	}

	#attrs = {}


	/**
	 * Set attributes
	 * @param  {(Array|Object)} attrs Attributes as an array [[key,value],...] or map {key: value,...}
	 * @return {CircleProgress}       The CircleProgress instance
	 */
	attr(attrs) {
		if(!['string', 'object'].includes(typeof attrs)) {
			throw new TypeError(`Wrong argument passed to attr. Expected object, got "${typeof attrs}"`);
		}

		if(typeof attrs === 'string') {
			if(arguments.length === 1) {
				return this._get(attrs);
			}
			attrs = [[attrs, arguments[1]]];
		}

		if(!Array.isArray(attrs)) {
			attrs = Object.keys(attrs).map(key => [key, attrs[key]]);
		}

		attrs.forEach(([key, value]) => this._set(key, value));
		return this;
	}

	/**
	 * Get property value
	 * Flushes pending updates.
	 */
	_get(key) {
		this._flushBatch();
		return this.#attrs[key];
	}


	/**
	 * Set an attribute to a value
	 * @param {string} key Attribute name
	 * @param {*}      val Attribute value
	 * @return {false|void} false if the value is the same as the current one, void otherwise
	 */
	_set(key, val) {
		val = this._formatValue(key, val);
		if(val === undefined) throw new TypeError(`Failed to set the ${key} property on CircleProgress: The provided value is non-finite.`);
		this._scheduleUpdate(key, val);
	}

	/**
	 * Properties batched for update
	 */
	#batch = null;

	/**
	 * A promise that resolves when the element has finished updating
	 */
	updateComplete = null;

	/**
	 * Schedule an update of a property on microtask level
	 * @param  {string} key Property name
	 * @param  {*}      val Property value
	 */
	_scheduleUpdate(key, val) {
		if(!this.#batch) {
			this.#batch = {};
			this.updateComplete = Promise.resolve().then(() => this._flushBatch());
		}
		this.#batch[key] = val;
	}

	_flushBatch() {
		if (!this.#batch) {
			return;
		}
		const batch = this.#batch;
		this.#batch = null;

		let min = batch.min ?? this.#attrs.min;
		let max = batch.max ?? this.#attrs.max;

		if('min' in batch && batch.min >= max) {
			min = batch.min = max;
		}
		if('max' in batch && batch.max <= min) {
			max = batch.max = min;
		}
		if('value' in batch && !(batch.unconstrained ?? this.#attrs.unconstrained)) {
			if(min != null && batch.value < min) batch.value = min;
			if(max != null && batch.value > max) batch.value = max;
		}

		for (const [key, val] of Object.entries(batch)) {
			if(this.#attrs[key] === val) {
				continue;
			}
			this.#attrs[key] = val;
			if(key in ariaAttrs) {
				if(val !== undefined) this.graph.paper.svg.setAttribute(ariaAttrs[key], val);
				else this.graph.paper.svg.removeAttribute(ariaAttrs[key]);
			}
			if(['min', 'max', 'unconstrained'].includes(key) && (this.value > this.max || this.value < this.min)) {
				this.value = Math.min(this.max, Math.max(this.min, this.value));
			}
			if(key === 'textFormat') {
				this._initText();
				const circleThickness = val === 'valueOnCircle' ? 16 : 8;
				this.graph.sector.attr('stroke-width', circleThickness);
				this.graph.circle.attr('stroke-width', circleThickness);
			}
			this.reflectPropToAttribute(key);
		}
		this.updateGraph();
	}


	/**
	 * Format attribute value according to its type
	 * @param  {string} key Attribute name
	 * @param  {*}      val Attribute value
	 * @return {*}          Formatted attribute value
	 */
	_formatValue(key, val) {
		switch(key) {
			case 'value':
			case 'min':
			case 'max':
				val = Number(val);
				if(!Number.isFinite(val)) val = undefined;
				break;
			case 'startAngle':
				val = Number(val);
				if(!Number.isFinite(val)) val = undefined;
				else val = Math.max(0, Math.min(360, val));
				break;
			case 'anticlockwise':
			case 'unconstrained':
				val = !!val;
				break;
			case 'indeterminateText':
				val = String(val);
				break;
			case 'textFormat':
				if(typeof val !== 'function' && !['valueOnCircle', 'horizontal', 'vertical', 'percent', 'value', 'none'].includes(val)) {
					throw new Error(`Failed to set the "textFormat" property on CircleProgress: the provided value "${val}" is not a legal textFormat identifier.`);
				}
				break;
			case 'animation':
				if(typeof val !== 'string' && typeof val !== 'function') {
					throw new TypeError(`Failed to set "animation" property on CircleProgress: the value must be either string or function, ${typeof val} passed.`);
				}
				if(typeof val === 'string' && val !== 'none' && !easings[val]) {
					throw new Error(`Failed to set "animation" on CircleProgress: the provided value ${val} is not a legal easing function name.`);
				}
				break;
		}
		return val;
	}


	/**
	 * Convert current value to angle
	 * The caller is responsible to check if the state is not indeterminate.
	 * This is done for optimization purposes as this method is called from within an animation.
	 * @return {number} Angle in degrees
	 */
	_valueToAngle(value = this.value) {
		return Math.min(
			360,
			Math.max(
				0,
				(value - this.min) / (this.max - this.min) * 360
			)
		);
	}


	/**
	 * Check wether the progressbar is in indeterminate state
	 * @return {boolean} True if the state is indeterminate, false if it is determinate
	 */
	_isIndeterminate() {
		return ['value', 'max', 'min'].some(key => typeof this[key] !== 'number');
	}


	/**
	 * Position the value text on the circle
	 * @param  {number} angle Angle at which to position the text
	 * @param  {number} r Circle radius measured to the middle of the stroke
	 *                   as returned by {@link CircleProgress.getRadius}, where text should be.
	 *                   The radius is passed rather than calculated inside the function
	 *                   for optimization purposes as this method is called from within an animation.
	 */
	_positionValueText(angle, r) {
		const coords = polarToCartesian(r, angle);
		this.graph.textVal.attr({x: 50 + coords.x, y: 50 + coords.y});
	}


	/**
	 * Generate text representation of the values based on {@link CircleProgress#textFormat}
	 */
	_initText() {
		const format = this.textFormat;
		this.graph.text.content('');
		if (typeof format === 'string' && ['valueOnCircle', 'horizontal', 'vertical'].includes(format)) {
			this.graph.textVal = this.graph.paper.element(
				'tspan',
				{class: 'text-value', part: 'text-value'},
				'',
				this.graph.text,
			);
			if (['horizontal', 'vertical'].includes(format)) {
				this.graph.textSeparator = this.graph.paper.element(
					'tspan',
					{class: 'text-separator', part: 'text-separator'},
					'',
					this.graph.text,
				);
			}
			this.graph.textMax = this.graph.paper.element(
				'tspan',
				{class: 'text-max', part: 'text-max'},
				'',
				this.graph.text,
			);
		}
		switch(format) {
		case 'valueOnCircle':
			this.graph.textVal.attr({
				x: 0,
				y: 0,
				dy: '0.4em',
			});
			this.graph.textMax.attr({
				x: 50,
				y: 50,
				dy: '0.4em',
			});
			break;

		case 'horizontal':
			this.graph.textSeparator.content('/');
			break;

		case 'vertical':
			this.graph.textVal.attr({x: 50, dy: '-0.25em'});
			this.graph.textSeparator.attr({x: 50, dy: '0.1em'}).content('___');
			this.graph.textMax.attr({x: 50, dy: '1.2em'});
			break;
		}
		this.graph.text.attr('dy', format === 'vertical' ? '' : '0.4em');
	}

	/**
	 * @type {ReturnType<animator>|null} Animation
	 */
	#animator = null


	/**
	 * Update graphics
	 */
	updateGraph() {
		const startAngle = this.startAngle - 90;
		const r = this.getRadius();

		this.#animator?.cancel();
		if(!this._isIndeterminate()) {
			const clockwise = !this.anticlockwise;
			let angle = this._valueToAngle();
			this.graph.circle.attr('r', r);
			if(this.animation !== 'none' && this.value !== this.graph.value) {
				this.#animator = animator(this.animation, this.graph.value, this.value - this.graph.value, this.animationDuration, value => {
					angle = this._valueToAngle(value);
					this.graph.sector.attr('d', makeSectorPath(50, 50, r, startAngle, angle, clockwise));
					this._updateText(value === this.value ? value : Math.round(value), (2 * startAngle + angle) / 2, r);
				});
			} else {
				this.graph.sector.attr('d', makeSectorPath(50, 50, r, startAngle, angle, clockwise));
				this._updateText(this.value, (2 * startAngle + angle) / 2, r);
			}
			this.graph.value = this.value;
		} else {
			this._updateText(this.value, startAngle, r);
		}
	}

	/**
	 * Update texts
	 */
	_updateText(value, angle, r) {
		if(typeof this.textFormat === 'function') {
			this.graph.text.content(this.textFormat(value, this.max));
			return
		}

		switch (this.textFormat) {
			case 'value':
				this.graph.text.el.textContent = (value !== undefined ? value : this.indeterminateText);
				break;
			case 'percent':
				this.graph.text.el.textContent = (value !== undefined && this.max != null ? Math.round(value / this.max * 100) : this.indeterminateText) + '%';
				break;
			case 'none':
				this.graph.text.el.textContent = '';
				break;
			default:
				this.graph.textVal.el.textContent = value !== undefined ? value : this.indeterminateText;
				this.graph.textMax.el.textContent = this.max !== undefined ? this.max : this.indeterminateText;
				if(this.textFormat === 'valueOnCircle') {
					this._positionValueText(angle, r);
				}
		}
	}


	/**
	 * Get circles' radius based on the calculated stroke widths of the value path and circle
	 * @return {number} The radius
	 */
	getRadius() {
		return 50 - Math.max(
			this._getStrokeWidth(this.graph.circle.el),
			this._getStrokeWidth(this.graph.sector.el),
		) / 2;
	}

	/**
	 * Get SVG element's stroke-width
	 */
	_getStrokeWidth(el) {
		return Number.parseFloat(this.ownerDocument.defaultView?.getComputedStyle(el)['stroke-width'] || 0);
	}
}


customElements.define('circle-progress', CircleProgress);

export { CircleProgress as default };
//# sourceMappingURL=circle-progress.js.map
